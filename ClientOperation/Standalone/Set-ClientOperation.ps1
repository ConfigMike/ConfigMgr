#Requires -Version 3.0<#    .SYNOPSIS        Starts, cancels or deletes a Client Operation    .DESCRIPTION         Starts, cancels or deletes a System Center Configuration Manager (SCCM) Client Operation        like a SCEP FullScan, Software Update Evaluation or Computer Policy download and evaluation.    .EXAMPLE        .\Set-ClientOperation.ps1 -Start FullScan -ResourceName TestComputer        Starts a Full Scan on one computer    .EXAMPLE        .\Set-ClientOperation.ps1 -Start QuickScan -CollectionName "All Windows 10 machines"                Starts a QuickScan on all members of a collection    .EXAMPLE        .\Set-ClientOperation.ps1 -Cancel -All -ProviderServer CMServer01 -SiteCode XYZ                Cancels All Client Operations from a remote computer    .EXAMPLE        .\Set-ClientOperation.ps1 -Delete -Expired -ProviderServer CMServer01 -SiteCode XYZ -Credential (Get-Credential CMAdmin)        Deletes all Expired Client Operations from a remote computer with different credentials    .LINK        http://maikkoster.com/start-cancel-or-delete-a-sccm-client-operation/        https://github.com/MaikKoster/ConfigMgr/blob/master/ClientOperation/Set-ClientOperation.ps1    .NOTES        Copyright (c) 2015 Maik Koster        Author:  Maik Koster        Version: 1.1        Date:    08.12.2015        Version History:            1.0 - 07.12.2015 - Published script            1.1 - 08.12.2015 - Updated Help. Fixed Whatif issue            1.2 - 25.03.2015 - Moved common ConfigMgr functions to ConfigMgr Module                             - Added standalone version#>[CmdletBinding(SupportsShouldProcess)]Param (    # Starts the specified Client Operation. Valid values are:    #    FullScan                ->  to intiate a SCEP Full Scan    #    QuickScan               ->  to initiate a SCEP Quick Scan    #    DownloadDefinition      ->  to initiate a SCEP definition download    #    EvaluateSoftwareUpdates ->  to initiate a software Update evaluation cycle    #    RequestComputerPolicy   ->  to initiate a donwload and process of the current computer policy    #    RequestUserPolicy       ->  to initiate a download and process of the current User policy    [Parameter(Mandatory,ParameterSetname="Start")]    [ValidateSet("FullScan", "QuickScan", "DownloadDefinition", "EvaluateSoftwareUpdates", "RequestComputerPolicy", "RequestUserPolicy")]    [string]$Start,    # Cancels a running client Operation. OperationID must be supplied.    [Parameter(Mandatory,ParameterSetname="Cancel")]    [Parameter(Mandatory,ParameterSetname="CancelAll")]    [switch]$Cancel,    # Deletes a Client Operation. OperationID must be supplied.    [Parameter(Mandatory,ParameterSetname="Delete")]    [Parameter(Mandatory,ParameterSetname="DeleteAll")]    [Parameter(Mandatory,ParameterSetname="DeleteExpired")]    [switch]$Delete,    # CollectionID of the target(s) for the Client Operation.    # Supply either CollectionID or CollectionName.     # If no ResourceID/ResourceName is specified, all Collection members will be targeted.    # If no CollectionID is supplied, "SMS00001" (All Systems) will be used,    # but at least one ResourceID/ResourceName must be specified.    [Parameter(ParameterSetname="Start")]    [ValidateNotNullOrEmpty()]    [string]$CollectionID,    # Collection name of the targets for the Client Operation.    # Supply either CollectionName or CollectionID    # If no ResourceID/ResourceName is specified, all Collection members will be targeted.    # If no CollectionName is supplied, "All Systems" (SMS00001) will be used,    # but at least one ResourceID/ResourceName must be specified.    [Parameter(ParameterSetname="Start")]    [ValidateNotNullOrEmpty()]    [string]$CollectionName,    # ResourceID of the target for the Client operation.     # Supply either ResourceId or ResourceName.    # Multiple ResourceIDs can be supplied.    [Parameter(ParameterSetname="Start")]    [uint32[]]$ResourceID,    # ResourceName of the target for the client operation.    # Supply either ResourceName or ResourceID.    # Multiple ResourceNames can be supplied.    [Parameter(ParameterSetname="Start")]    [string[]]$ResourceName,        # The OperationID of the Client Operation that shall be canceled or deleted.    # Multiple OperationIDs can be supplied.    [Parameter(Mandatory,ParameterSetname="Cancel")]    [Parameter(Mandatory,ParameterSetname="Delete")]    [uint32[]]$OperationID,    [Parameter(Mandatory,ParameterSetname="CancelAll")]    [Parameter(Mandatory,ParameterSetname="DeleteAll")]    # If supplied all Client Operations will be canceled or deleted.    [switch]$All,    [Parameter(Mandatory,ParameterSetname="DeleteExpired")]    # If supplied all expired Client Operations will be deleted.    [switch]$Expired,    # The ConfigMgr Provider Server name.     # If no value is specified, the script assumes to be executed on the Site Server.    [Alias("SiteServer", "ServerName")]    [string]$ProviderServer = ".",    # The ConfigMgr provider Site Code.     # If no value is specified, the script will evaluate it from the Site Server.    [string]$SiteCode,    # Credentials to connect to the Provider Server.    [System.Management.Automation.CredentialAttribute()]$Credential)Process {    ###############################################################################    # Start Script    ###############################################################################        # Ensure this isn't processed when dot sourced by e.g. Pester Test trun    if ($MyInvocation.InvocationName -ne '.') {        # Prepare parameters for splatting        $MainParams = $PSBoundParameters        $MainParams.Remove("ProviderServer")        $MainParams.Remove("SiteCode")        # Create a connection to the ConfigMgr Provider Server        $ConnParams = @{ServerName = $ProviderServer;SiteCode = $SiteCode;}        if ($PSBoundParameters["Credential"]) {            $connParams.Credential = $Credential            $MainParams.Remove("Credential")        }                New-CMConnection @ConnParams        # Start processing        Main @PSBoundParameters    }}Begin {Function Test-CMConnection {    if ( ([string]::IsNullOrWhiteSpace($global:CMProviderServer)) -or             ([string]::IsNullOrWhiteSpace($global:CMSiteCode)) -or             ([string]::IsNullOrWhiteSpace($global:CMNamespace)) -or             ($global:CMSession -eq $null)) {        New-CMConnection        $true    } else {        $true    }}Function Get-CallerPreference {    <#    .Synopsis        Fetches "Preference" variable values from the caller's scope.    .DESCRIPTION        Script module functions do not automatically inherit their caller's variables, but they can be        obtained through the $PSCmdlet variable in Advanced Functions.  This function is a helper function        for any script module Advanced Function; by passing in the values of $ExecutionContext.SessionState        and $PSCmdlet, Get-CallerPreference will set the caller's preference variables locally.    .PARAMETER Cmdlet        The $PSCmdlet object from a script module Advanced Function.    .PARAMETER SessionState        The $ExecutionContext.SessionState object from a script module Advanced Function.  This is how the        Get-CallerPreference function sets variables in its callers' scope, even if that caller is in a different        script module.    .PARAMETER Name        Optional array of parameter names to retrieve from the caller's scope.  Default is to retrieve all        Preference variables as defined in the about_Preference_Variables help file (as of PowerShell 4.0)        This parameter may also specify names of variables that are not in the about_Preference_Variables        help file, and the function will retrieve and set those as well.    .EXAMPLE        Get-CallerPreference -Cmdlet $PSCmdlet -SessionState $ExecutionContext.SessionState        Imports the default PowerShell preference variables from the caller into the local scope.    .EXAMPLE        Get-CallerPreference -Cmdlet $PSCmdlet -SessionState $ExecutionContext.SessionState -Name 'ErrorActionPreference','SomeOtherVariable'        Imports only the ErrorActionPreference and SomeOtherVariable variables into the local scope.    .EXAMPLE        'ErrorActionPreference','SomeOtherVariable' | Get-CallerPreference -Cmdlet $PSCmdlet -SessionState $ExecutionContext.SessionState        Same as Example 2, but sends variable names to the Name parameter via pipeline input.    .INPUTS        String    .OUTPUTS        None.  This function does not produce pipeline output.    .LINK        about_Preference_Variables    #>    [CmdletBinding(DefaultParameterSetName = 'AllVariables')]    param (        [Parameter(Mandatory = $true)]        [ValidateScript({ $_.GetType().FullName -eq 'System.Management.Automation.PSScriptCmdlet' })]        $Cmdlet,        [Parameter(Mandatory = $true)]        [System.Management.Automation.SessionState]        $SessionState,        [Parameter(ParameterSetName = 'Filtered', ValueFromPipeline = $true)]        [string[]]        $Name    )    Begin {        $filterHash = @{}    }        Process {        if ($null -ne $Name) {            foreach ($string in $Name) {                $filterHash[$string] = $true            }        }    }    End {        # List of preference variables taken from the about_Preference_Variables help file in PowerShell version 4.0        $vars = @{            'ErrorView' = $null            'FormatEnumerationLimit' = $null            'LogCommandHealthEvent' = $null            'LogCommandLifecycleEvent' = $null            'LogEngineHealthEvent' = $null            'LogEngineLifecycleEvent' = $null            'LogProviderHealthEvent' = $null            'LogProviderLifecycleEvent' = $null            'MaximumAliasCount' = $null            'MaximumDriveCount' = $null            'MaximumErrorCount' = $null            'MaximumFunctionCount' = $null            'MaximumHistoryCount' = $null            'MaximumVariableCount' = $null            'OFS' = $null            'OutputEncoding' = $null            'ProgressPreference' = $null            'PSDefaultParameterValues' = $null            'PSEmailServer' = $null            'PSModuleAutoLoadingPreference' = $null            'PSSessionApplicationName' = $null            'PSSessionConfigurationName' = $null            'PSSessionOption' = $null            'ErrorActionPreference' = 'ErrorAction'            'DebugPreference' = 'Debug'            'ConfirmPreference' = 'Confirm'            'WhatIfPreference' = 'WhatIf'            'VerbosePreference' = 'Verbose'            'WarningPreference' = 'WarningAction'        }        foreach ($entry in $vars.GetEnumerator()) {            if (([string]::IsNullOrEmpty($entry.Value) -or -not $Cmdlet.MyInvocation.BoundParameters.ContainsKey($entry.Value)) -and                ($PSCmdlet.ParameterSetName -eq 'AllVariables' -or $filterHash.ContainsKey($entry.Name))) {                $variable = $Cmdlet.SessionState.PSVariable.Get($entry.Key)                                if ($null -ne $variable) {                    if ($SessionState -eq $ExecutionContext.SessionState) {                        Set-Variable -Scope 1 -Name $variable.Name -Value $variable.Value -Force -Confirm:$false -WhatIf:$false                    } else {                        $SessionState.PSVariable.Set($variable.Name, $variable.Value)                    }                }            }        }        if ($PSCmdlet.ParameterSetName -eq 'Filtered') {            foreach ($varName in $filterHash.Keys) {                if (-not $vars.ContainsKey($varName)) {                    $variable = $Cmdlet.SessionState.PSVariable.Get($varName)                                    if ($null -ne $variable) {                        if ($SessionState -eq $ExecutionContext.SessionState) {                            Set-Variable -Scope 1 -Name $variable.Name -Value $variable.Value -Force -Confirm:$false -WhatIf:$false                        } else {                            $SessionState.PSVariable.Set($variable.Name, $variable.Value)                        }                    }                }            }        }    } # end}Function Invoke-CimCommand {    PARAM(        # Specifies the Cim based Command that shall be executed        [Parameter(Mandatory)]        [scriptblock]$Command    )    $RetryCount = 0    Do {        $Retry = $false        Try {            & $Command        } Catch {            if ($_.Exception -ne $null) {                if (($_.Exception.HResult -eq -2147023169 ) -or ($_.Exception.ErrorData.error_Code -eq 2147944127)) {                    if ($RetryCount -ge 3) {                        $Retry = $false                    } else {                        $RetryCount += 1                        $Retry = $true                        Write-Verbose "CIM/WMI command failed with Error 2147944127 (HRESULT 0x800706bf)."                        Write-Verbose "Common RPC error, retry on default. Current retry count $RetryCount"                    }                } else {                    throw $_.Exception                }             } else {                throw             }        }    } While ($Retry)}Function Get-CMSession {    [CmdLetBinding()]    PARAM (        # Specifies the ComputerName to connect to.         [Parameter(Position=0)]        [ValidateNotNullOrEmpty()]        [string]$ComputerName = $env:COMPUTERNAME,                    # Specifies the credentials to connect to the Provider Server.        [System.Management.Automation.Credential()]$Credential = [System.Management.Automation.PSCredential]::Empty    )    Begin {        Get-CallerPreference -Cmdlet $PSCmdlet -SessionState $ExecutionContext.SessionState         $Opt = New-CimSessionOption -Protocol Dcom        $SessionParams = @{            ErrorAction = 'Stop'        }        if ($PSBoundParameters['Credential']) {            $SessionParams.Credential = $Credential        }    }    Process {        # Check if there is an already existing session to the specified computer        $Session = Get-CimSession | Where-Object { $_.ComputerName -eq $ComputerName} | Select-Object -First 1        if ($Session -eq $null) {                        $SessionParams.ComputerName = $ComputerName            $WSMan = Test-WSMan -ComputerName $ComputerName -ErrorAction SilentlyContinue            if (($WSMan -ne $null) -and ($WSMan.ProductVersion -match 'Stack: ([3-9]|[1-9][0-9]+)\.[0-9]+')) {                try {                    Write-Verbose -Message "Attempt to connect to $ComputerName using the WSMAN protocol."                    $Session = New-CimSession @SessionParams                } catch {                    Write-Verbose "Unable to connect to $ComputerName using the WSMAN protocol. Test DCOM ..."                                        }            }             if ($Session -eq $null) {                $SessionParams.SessionOption = $Opt                 try {                    Write-Verbose -Message "Attempt to connect to $ComputerName using the DCOM protocol."                    $Session = New-CimSession @SessionParams                } catch {                    Write-Error -Message "Unable to connect to $ComputerName using the WSMAN or DCOM protocol. Verify $ComputerName is online or credentials and try again."                }            }                            If ($Session -eq $null) {                $Session = Get-CimSession | Where-Object { $_.ComputerName -eq $ComputerName} | Select-Object -First 1            }        }        Return $Session    }}Function Invoke-CMMethod {    [CmdletBinding(SupportsShouldProcess, DefaultParameterSetName="ClassName")]    PARAM (        # Specifies the ConfigMgr WMI provider Class Name        # Needs to be supplied for static class methods        [Parameter(Mandatory,ParameterSetName="ClassName")]         [ValidateNotNullOrEmpty()]        [string]$ClassName,                    # Specifies the ConfigMgr WMI provider object        # Needs to be supplied for instance methods        [Parameter(Mandatory,ParameterSetName="ClassInstance")]         [ValidateNotNullOrEmpty()]        [object]$ClassInstance,          # Specifies the Method Name        [Parameter(Mandatory)]        [ValidateNotNullOrEmpty()]        [string]$MethodName,        # Specifies the Arguments to be supplied to the method.        # Should be a hashtable with key/name pairs.        [hashtable]$Arguments,        # If set, ReturnValue will not be evaluated        # Usefull if ReturnValue does not indicated successfull execution        [switch]$SkipValidation    )    Begin {        Get-CallerPreference -Cmdlet $PSCmdlet -SessionState $ExecutionContext.SessionState     }            Process {        if ($PSCmdlet.ShouldProcess("$CMProviderServer", "Invoke $MethodName")) {              # Ensure ConfigMgr Provider information is available            if (Test-CMConnection) {                    if ($ClassInstance -ne $null) {                        $Result = Invoke-CimCommand {Invoke-CimMethod -InputObject $ClassInstance -MethodName $MethodName -Arguments $Arguments -ErrorAction Stop}                    } else {                        $Result = Invoke-CimCommand {Invoke-CimMethod -CimSession $global:CMSession -Namespace $CMNamespace -ClassName $ClassName -MethodName $MethodName -Arguments $Arguments  -ErrorAction Stop}                    }                    if ((!($SkipValidation.IsPresent)) -and ($Result -ne $null)) {                        if ($Result.ReturnValue -eq 0) {                            Write-Verbose "Successfully invoked $MethodName on $CMProviderServer."                        } else {                            Write-Verbose "Failed to invoked $MethodName on $CMProviderServer. ReturnValue: $($Result.ReturnValue)"                        }                    }                 Return $Result            }        }    }}Function New-SearchString {    [CmdLetBinding(DefaultParameterSetName="String")]    [Outputtype([string])]    PARAM (        [Parameter(Mandatory,ValueFromPipelineByPropertyName)]        [ValidateNotNullOrEmpty()]        [string]$PropertyName,        [Parameter(Mandatory,ParameterSetName="String",ValueFromPipeline,ValueFromPipelineByPropertyName)]        [ValidateNotNullOrEmpty()]        [string[]]$StringProperty,        [Parameter(ParameterSetName="String")]        [switch]$Search,        [Parameter(Mandatory,ParameterSetName="Int",ValueFromPipelineByPropertyName)]        [ValidateNotNullOrEmpty()]        [uint32[]]$IntProperty    )    Begin {    }    Process {        $Filter = @()        if ($PSCmdlet.ParameterSetName -eq "String") {            if ($Search.IsPresent) {                $Operation = "LIKE"            } else {                $Operation = "="            }            $StringFilter = @()            foreach ($Prop In $StringProperty) {                $StringFilter += "($Propertyname $Operation '$Prop')"            }            if ($StringFilter.Count -gt 1) {                $Filter += "($($StringFilter -join ' OR '))"            } else {                $Filter += $StringFilter            }        } elseif ($PSCmdlet.ParameterSetName -eq "Int") {            $IntFilter = @()            foreach ($Prop In $IntProperty) {                $IntFilter += "($Propertyname = $Prop)"            }            if ($IntFilter.Count -gt 1) {                $Filter += "($($IntFilter -join ' OR '))"            } else {                $Filter += $IntFilter            }        }        $Result = ($Filter -join ' AND ')        Write-Verbose "Created WMI search string '$Result'."                $Result    }}Function Get-CMInstance {    [CmdletBinding()]    PARAM (        # Specifies the ConfigMgr WMI provider Class Name        [Parameter(Mandatory)]         [ValidateNotNullOrEmpty()]        [string]$ClassName,         # Specifies the Where clause to filter the specified ConfigMgr WMI provider class.        # If no filter is supplied, all objects will be returned.        [string]$Filter,        # Indicates that the requested class contains lazy properties that shall be returned.        # As the CIM CmdLets don't support lazy properties, the objects will be queried using        # the deprecated WMI CmdLets.        [switch]$ContainsLazy    )    Begin {        Get-CallerPreference -Cmdlet $PSCmdlet -SessionState $ExecutionContext.SessionState     }    Process {        if ([string]::IsNullOrWhiteSpace($ClassName)) { throw "Class is not specified" }        # Ensure ConfigMgr Provider information is available        if (Test-CMConnection) {            if (($Filter.Contains(" JOIN ")) -or ($ContainsLazy.IsPresent)) {                Write-Verbose "Fall back to WMI cmdlets"                                $WMIParams = @{                    ComputerName = $global:CMProviderServer;                    Namespace = $CMNamespace;                    Class = $ClassName;                    Filter = $Filter                }                if ($global:CMCredential -ne [System.Management.Automation.PSCredential]::Empty) {                    $WMIParams.Credential = $CMCredential                }                Invoke-CimCommand {Get-WmiObject @WMIParams -ErrorAction Stop}            } else {                $InstanceParams = @{                    CimSession = $global:CMSession                    Namespace = $global:CMNamespace                    ClassName = $ClassName                }                if ($Filter -ne "") {                    $InstanceParams.Filter = $Filter                }                Invoke-CimCommand {Get-CimInstance @InstanceParams -ErrorAction Stop}            }        }    }}Function New-CMConnection {    [CmdletBinding()]    PARAM (        # Specifies the ConfigMgr Provider Server name.         # If no value is specified, the script assumes to be executed on the Site Server.        [Alias("ServerName", "Name")]        [string]$ProviderServerName = $env:COMPUTERNAME,        # Specifies the ConfigMgr provider Site Code.         # If no value is specified, the script will evaluate it from the Site Server.        [string]$SiteCode,        # Specifies the Credentials to connect to the Provider Server.        [System.Management.Automation.Credential()]$Credential = [System.Management.Automation.PSCredential]::Empty    )    Begin {        Get-CallerPreference -Cmdlet $PSCmdlet -SessionState $ExecutionContext.SessionState     }    Process {                # Get or Create session object to connect to currently provided Providerservername        # Ensure processing stops if it fails to create a session        $SessionParams = @{            ErrorAction = "Stop"            ComputerName = $ProviderServerName        }        if ($PSBoundParameters["Credential"]) {            $SessionParams.Credential = $Credential        }                $CMSession = Get-CMSession @SessionParams        # Get Provider location        if ($CMSession -ne $null) {            $ProviderLocation = $null            if ($SiteCode -eq $null -or $SiteCode -eq "") {                Write-Verbose "Get provider location for default site on server $ProviderServerName"                $ProviderLocation = Invoke-CimCommand {Get-CimInstance -CimSession $CMSession -Namespace "root\sms" -ClassName SMS_ProviderLocation -Filter "ProviderForLocalSite = true" -ErrorAction Stop}            } else {                Write-Verbose "Get provider location for site $SiteCode on server $ProviderServerName"                $ProviderLocation = Invoke-CimCommand {Get-CimInstance -CimSession $CMSession -Namespace "root\sms" -ClassName SMS_ProviderLocation -Filter "SiteCode = '$SiteCode'" -ErrorAction Stop}            }            if ($ProviderLocation -ne $null) {                # Split up the namespace path                $Parts = $ProviderLocation.NamespacePath -split "\\", 4                Write-Verbose "Provider is located on $($ProviderLocation.Machine) in namespace $($Parts[3])"                # Set Script variables used by ConfigMgr related functions                $global:CMProviderServer = $ProviderLocation.Machine                $global:CMNamespace = $Parts[3]                $global:CMSiteCode = $ProviderLocation.SiteCode                $global:CMCredential = $Credential                # Create and store session if necessary                if ($global:CMProviderServer -ne $ProviderServerName) {                    $SessionParams.ComputerName = $global:CMProviderServer                    $CMSession = Get-CMSession @SessionParams                }                if ($CMSession -eq $null) {                    Throw "Unable to establish CIM session to $global:CMProviderServer"                } else {                    $global:CMSession = $CMSession                }            } else {                # Clear global variables                $global:CMProviderServer = [string]::Empty                $global:CMNamespace = [string]::Empty                $global:CMSiteCode = [string]::Empty                $global:CMCredential = $null                Throw "Unable to connect to specified provider"            }        } else {            # Clear global variables            $global:CMProviderServer = [string]::Empty            $global:CMNamespace = [string]::Empty            $global:CMSiteCode = [string]::Empty            $global:CMCredential = $null            Throw "Unable to create CIM session to $ProviderServerName"        }    }}Function Remove-ClientOperation {    [CmdLetBinding(SupportsShouldProcess)]    PARAM (        # Specifies the OperationID of the Client Operation that shall be deleted.        # Multiple OperationIDs can be supplied.        [Parameter(Mandatory,ValueFromPipeline)]        [Alias("OperationID")]        [uint32[]]$ID    )    Begin {        Get-CallerPreference -Cmdlet $PSCmdlet -SessionState $ExecutionContext.SessionState     }            Process {                    foreach ($OpID in $ID) {            if ($PSCmdlet.ShouldProcess("SMS_ClientOperation.OperationID=""$OpId""","DeleteClientOperation")) {                Write-Verbose "Delete Client Operation $OpID."                Invoke-CMMethod -ClassName "SMS_ClientOperation" -MethodName "DeleteClientOperation" -Arguments @{OperationID = $OpID}            }        }    }}Function Get-Collection {    [CmdLetBinding(DefaultParameterSetName="ID")]    PARAM (        # Specifies the CollectionID        [Parameter(Mandatory, ParameterSetName="ID",ValueFromPipeline,ValueFromPipelineByPropertyName)]        [ValidateNotNullOrEmpty()]        [Alias("CollectionID")]        [string[]]$ID,        # Specifies the Collection Name        # If Search is set, the name can include the default WQL placeholders [],^,% and _        [Parameter(Mandatory, ParameterSetName="Name",ValueFromPipelineByPropertyName)]        [Alias("CollectionName")]        [string[]]$Name,        # Specifies if Name contains a search string        [Parameter(ParameterSetName="Name")]        [switch]$Search,        # Specifies the Collection Type        [Parameter(ParameterSetName="Name")]        [ValidateSet("Any", "Device", "User", "Other")]        [Alias("CollectionType")]        [string]$Type = "Any",        # Specifies a custom filter to use        [Parameter(Mandatory, ParameterSetName = "Filter")]        [ValidateNotNullOrEmpty()]        [string]$Filter     )    Begin {        Get-CallerPreference -Cmdlet $PSCmdlet -SessionState $ExecutionContext.SessionState     }    Process {        # Prepare filter        $CollectionFilter = @()        if ($PSCmdlet.ParameterSetName -eq "ID") {            $CollectionFilter += New-SearchString -PropertyName "CollectionID" -StringProperty $ID         } elseif ($PSCmdlet.ParameterSetName -eq "Filter") {            $CollectionFilter += $Filter        } else {            $CollectionFilter += New-SearchString -PropertyName "Name" -StringProperty $Name -Search:($Search.IsPresent)            Switch ($Type){                "Device" {$CollectionFilter += "(CollectionType = 2)"}                "User" {$CollectionFilter += "(CollectionType = 1)"}                "Other" {$CollectionFilter += "(CollectionType = 0)"}            }        }                $Filter = "($($CollectionFilter -join ' AND '))"        Write-Verbose "Get Collection(s) by filter $Filter"        Get-CMInstance -ClassName "SMS_Collection" -Filter $Filter    }}Function Get-ClientOperation {    [CmdLetBinding()]    PARAM(        # Specifies if only expired Client Operations shall be returned        [switch]$Expired    )    if ($Expired.IsPresent) {                Get-CMInstance -ClassName "SMS_ClientOperation" -Filter "((State = 0) OR (State = 2))"     } else {        Get-CMInstance -ClassName "SMS_ClientOperation"    } }Function Get-Device {    [CmdLetBinding(DefaultParameterSetName="Name")]    PARAM(        # Specifies the ResourceID        [Parameter(Mandatory, ParameterSetName="ID", ValueFromPipelineByPropertyName)]        [ValidateNotNullOrEmpty()]        [Alias("ResourceID")]        [uint32[]]$ID,        # Specifies the Computer Name        [Parameter(Mandatory, ParameterSetName="Name",ValueFromPipeline,ValueFromPipelineByPropertyName)]        [ValidateNotNullOrEmpty()]        [Alias("ComputerName", "DeviceName")]        [string[]]$Name,        # Specifies if Name contains a search string        [Parameter(ParameterSetName="Name")]        [switch]$Search,        # Specifies a custom filter to use        [Parameter(Mandatory,ParameterSetName="Filter", ValueFromPipelineByPropertyName)]        [ValidateNotNullOrEmpty()]        [string]$Filter    )    Begin {        Get-CallerPreference -Cmdlet $PSCmdlet -SessionState $ExecutionContext.SessionState     }    Process {        # Prepare filter        $DeviceFilter = @()        if ($PSCmdlet.ParameterSetName -eq "ID") {            $DeviceFilter += New-SearchString -PropertyName "ResourceID" -IntProperty $ID         } elseif ($PSCmdlet.ParameterSetName -eq "Filter") {            $DeviceFilter += $Filter        } else {            $DeviceFilter += New-SearchString -PropertyName "Name" -StringProperty $Name -Search:($Search.IsPresent)            $DeviceFilter += New-SearchString -PropertyName "NetbiosName" -StringProperty $Name -Search:($Search.IsPresent)        }        $Filter = "($($DeviceFilter -join ' OR '))"        Write-Verbose "Get Device(s) by filter $Filter"        Get-CMInstance -ClassName "SMS_R_System" -Filter $Filter    }}Function Stop-ClientOperation {    [CmdLetBinding()]    PARAM (                    # Specifies the OperationID of the Client Operation that shall be canceled.        # Multiple OperationIDs can be supplied.        [Parameter(Mandatory,ValueFromPipeline)]        [ValidateNotNullOrEmpty()]        [Alias("OperationID")]        [uint32[]]$ID    )    Begin {        Get-CallerPreference -Cmdlet $PSCmdlet -SessionState $ExecutionContext.SessionState     }            Process {                    foreach ($OpID in $ID) {            if ($PSCmdlet.ShouldProcess("SMS_ClientOperation.OperationID=""$OpId""","CancelClientOperation")) {                Write-Verbose "Cancel Client Operation $OpID."                Invoke-CMMethod -ClassName "SMS_ClientOperation" -MethodName "CancelClientOperation" -Arguments @{OperationID = $OpID}            }        }    }}Function Start-ClientOperation {    [CmdLetBinding()]    PARAM(         # Specifies the type of Client Operation to start. Valid values are:        #            #    FullScan                ->  to intiate a SCEP Full Scan        #    QuickScan               ->  to initiate a SCEP Quick Scan        #    DownloadDefinition      ->  to initiate a SCEP definition download        #    EvaluateSoftwareUpdates ->  to initiate a software Update evaluation cycle        #    RequestComputerPolicy   ->  to initiate a donwload and process of the current computer policy        #    RequestUserPolicy       ->  to initiate a download and process of the current User policy        [Parameter(Mandatory)]        [ValidateSet("FullScan", "QuickScan", "DownloadDefinition", "EvaluateSoftwareUpdates", "RequestComputerPolicy", "RequestUserPolicy")]        [string]$Operation,        # Specifies the CollectionID of the target(s) for the Client Operation.        # If no ResourceID is specified, all collection members will be targeted        [Parameter(Mandatory)]        [ValidateNotNullOrEmpty()]        [string]$CollectionID,        # Specifies the ResourceID of the target for the Client operation.         # Multiple ResourceIDs can be supplied.        [uint32[]]$ResourceID        #[uint32]$RandomizationWindow        # TBD    )            Begin {        Get-CallerPreference -Cmdlet $PSCmdlet -SessionState $ExecutionContext.SessionState     }    Process {        Write-Verbose "Starting Client operation $Operation on Collection $CollectionID"        # Convert operation to proper type value        switch ($Operation) {            "FullScan" { $Type = 1 }            "QuickScan" { $Type = 2 }            "DownloadDefinition" { $Type = 3 }            "EvaluateSoftwareUpdates" { $Type = 4}            "RequestComputerPolicy" { $Type = 8 }            "RequestUserPolicy" { $Type = 9 }            default { $Type = 0 }        }        # TODO Evaluate usage of RandomizationWindow        $Arguments = @{            Type = $Type            TargetCollectionID = $CollectionID            RandomizationWindow = $null            TargetResourceIDs = $ResourceID        }        Invoke-CMMethod -ClassName "SMS_ClientOperation" -MethodName "InitiateClientOperation" -Arguments $Arguments    }}    Set-StrictMode -Version Latest    ###############################################################################    # Main code    # This has been moved to a separate function to test the script logic for    # different parameters by Pester.    ###############################################################################    function Main {        [CmdLetBinding(SupportsShouldProcess)]        PARAM(            [string]$Start,            [switch]$Cancel,            [switch]$Delete,            [string]$CollectionID,            [string]$CollectionName,            [uint32[]]$ResourceID,            [string[]]$ResourceName,            [uint32[]]$OperationID,            [switch]$All,            [switch]$Expired,            [string]$ProviderServer,            [string]$SiteCode,            [System.Management.Automation.CredentialAttribute()]$Credential        )        if (!([string]::IsNullOrEmpty($Start))) {            # Resolve Collection name into CollectionID if necessary            if (!([System.String]::IsNullOrEmpty($CollectionName))) {                #Get collection ID for Collection                $Collection = Get-Collection -Type Device -Name $CollectionName                if ($Collection -ne $null) {                                         $CollectionID = $Collection.CollectionID                 } else {                    Write-Error "Unable to find Collection $CollectionName." -ErrorAction Stop                }            }            # Use "SMS00001" (All Systems) if no Collection is supplied            if ([string]::IsNullOrEmpty($CollectionID)) {                if (($ResourceID -ne $null) -or ($ResourceName -ne $null)) {                    $CollectionID = "SMS00001"                } else {                    Throw "At least one Resource needs to be specified if no CollectionID/CollectionName is supplied."                }            }            # Resolve Resource names into ResourceIDs if necessary            if ($ResourceName -ne $null ) {                $ResourceID = @(Get-Device -Name $ResourceName | Select-Object -ExpandProperty ResourceID)            }            Start-ClientOperation -Operation $Start -CollectionID $CollectionID -ResourceID $ResourceID        } else {                    if ($All.IsPresent) {                $OperationID = @(Get-ClientOperation | Select-Object -ExpandProperty ID)                        } elseif ($Expired.IsPresent) {                $OperationID = @(Get-ClientOperation -Expired | Select-Object -ExpandProperty ID)            }            if ($OperationID -ne $null) {                    if ($Cancel.IsPresent) {                    Stop-ClientOperation -OperationID $OperationID                } elseif ($Delete.IsPresent) {                    Remove-ClientOperation -OperationID $OperationID                }            } else {                Write-Warning "No Client Operation available."            }        }    }}
